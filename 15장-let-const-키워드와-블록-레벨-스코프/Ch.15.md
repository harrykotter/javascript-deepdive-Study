# 15장 let, const 키워드와 블록 레벨 스코프

## 🧐 var 키워드의 문제점

### 👉 변수 중복 선언 허용

이미 선언된 변수를 초기화문이 있는 변수로 다시 선언하면 중복으로 선언되는 문제가 있다. 이는 의도치 않게 기존에 선언한 변수 값이 변경되는 문제가 발생한다.

### 👉 함수 레벨 스코프

only 함수 내부에서만 지역 스코프를 지닌다. 기타 블록문에서 선언된 변수는 모두 전역 스코프를 지닌다.

### 👉 변수 호이스팅

var 키워드로 변수를 선언하면 JS의 변수 호이스팅으로 인해 스코프 최상단에서 정의된 것처럼 작동한다. 이로인해 변수 선언문 이전에 참조가 가능하다. (단, 값은 undefined로 반환)

  이는 let, const와 달리 var 키워드는 변수 선언 단계와 초기화 단계가 동시에 일어나 암묵적으로 undefined라고 정의된 상태로 보는 것이다.

## ☝ let 키워드

### 👉 변수 중복 선언 금지

var와 달리 let은 같은 스코프 내에 이름이 같은 변수를 중복 선언하면 SyntaxError가 발생한다.

### 👉 블록 레벨 스코프

let 키워드로 선언된 변수는 블록 레벨 스코프를 지녀 전역 스코프를 가지지 않는다.

### 👉 변수 호이스팅

let으로 선언한 변수는 변수 호이스팅이 발생하지 않는 것처럼 작동한다. 이는 let 키워드가 값을 할당하기 직전에 초기화 단계가 일어나기 때문이다.

### 👉 전역 객체와 let

  var 키워드로 선언한 전역 변수, 전역 함수는 전역 객체 window의 property가 된다. 즉, 브라우저 환경에서 전역 변수처럼 사용이 가능하다.

  하지만 let으로 선언한 전역 변수는 전역 객체 property가 될 수 없으므로 window.foo와 같이 접근할 수 없다.

## ☝ const 키워드

### 👉 선언과 초기화

const 키워드는 선언과 동시에 초기화 단계를 거쳐야 정상 작동된다. 그렇지 않으면 SyntaxError가 발생한다.

### 👉 재할당 금지

const는 변수에 원시값을 선언한 경우 변수 값을 변경할 수 없다. (constant는 상수이기 때문!)

### 👉 const 키워드와 객체

앞서 const는 재할당이 안되지만, const에 객체를 할당한 경우 객체가 바뀔 수 있다. 이는 객체가 원시 값이 아닌 참조값을 전달하기 때문이다. 즉, const는 재할당이 안될 뿐, 불변이라는 뜻이 아니다.

## 🧐 var vs. let vs. const

- ES6라면 var의 사용을 지양한다
- 재할당이 필요한 경우에 한해 let을 사용한다. 이때 스코프는 최대한 좁게!
- 변경하지 않는 읽기 전용 변수는 const로 선언한다.

🙋‍♀️ Q. var와 let 모두 변수 호이스팅이 일어나지만 참조에 있어 차이가 발생하는 이유는?