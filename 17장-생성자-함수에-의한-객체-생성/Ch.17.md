# 17장 생성자 함수에 의한 객체 생성

## 🧐 생성자 함수 (constructor)

<aside>
💡 `new` 연산자와 함께 호출하여 객체(인스턴스)를 생성하는 함수.
이때 생성된 객체를 인스턴스(instance)라 한다.

</aside>

## Object 생성자 함수

> **Object 생성자 함수**
`new`와 함께 호출 시 빈 객체를 생성하는 생성자 함수. `Object` 생성자 함수로 생성한 빈 객체에 프로퍼티 또는 메서드를 추가하여 객체를 완성하는 방식에 쓰이지만, 추천은 X
> 

### ☝ 객체 리터럴에 의한 객체 생성 방식의 문제점

 객체 리터럴에 의한 객체 생성은 직관적이고 간편하지만, 단 하나의 객체만 생성할 수 있다. 따라서 프로퍼티 구조가 동일한 여러 객체를 한 번에 생성할 수 없다.

### ☝ 생성자 함수에 의한 객체 생성 방식의 장점

 위의 객체 리터럴에 의한 객체 생성 방법의 단점을 생성자 함수에 의한 객체 생성으로 보완할 수 있다. 위 방법은 템플릿처럼 프로퍼티 구조가 동일한 여러 객체를 간편하게 생성할 수 있다.

### ❗This

자신의 프로퍼티나 메서드에 참조하기 위한 자기 참조 변수. 여기서 this가 가리키는 값은 동적으로 결정된다.

| 함수 호출 방식 | this가 가리키는 값 (this 바인딩) |
| --- | --- |
| 일반 함수로서 변수 | 전역 객체 |
| 메서드로서 호출 | 메서드를 호출한 객체 |
| 생성자 함수로서 호출 | 생성자 함수가 생성할 인스턴스 |

### 👉 생성자 함수의 인스턴스 생성 과정

인스턴스 생성 과정은 크게 두 단계로 볼 수 있다.

**첫 번째**, 인스턴스를 생성하는 단계

**두 번째**, 생성된 인스턴스를 초기화하는 단계

1. **인스턴스 생성과 this 바인딩**
암묵적으로 빈 객체(인스턴스)가 생성된 후, 이 인스턴스에 `this`가 바인딩된다. 이 과정은 런타임 이전에 실행된다.
※ `바인딩`: 식별자와 값을 연결하는 과정을 의미한다.

2. **인스턴스 초기화**
생성자 함수가 한 줄씩 실행되어서 `this`가 바인딩되어있는 인스턴스를 초기화하고, 매개변수를 인스턴스의 프로퍼티로 넣거나 메서드를 할당한다.

3. **인스턴스 반환**
완성된 인스턴스가 바인딩된 this가 암묵적으로 반환된다. 단,원시값이 있어도 원시값을 무시하고 this가 반환된다. 즉, this가 아닌 값을 반환하는 것은 위험! 함수 내부의 return문을 생략할 것!

### 👉 내부 메서드 `[[Call]]`과 `[[Construct]]`

 함수는 객체이지만 일반적인 객체와 달리 내부 슬롯과 내부 메서드를 포함, `[[Call]]`와 `[[Construct]]`같은 함수 객체의 내부 메서드를 추가로 지닌다.

`[[Call]]`: callable 속성을 지닌 함수 객체에 사용하는 내부 메서드, 모든 함수 객체가 지니고 있다.

`[[Construct]]`: 생성자 함수로서 호출할 수 있는 함수들에 사용한 내부 메서드. 이 메서드의 사용 여부에 따라 constructor와 non-constructor로 구분된다.

### 👉 `constructor`와 `non-constructor`의 구분 - 함수 정의 방식!

`constructor`: 함수 선언문, 함수 표현식, 클래스(클래스도 함수!)가 여기에 해당

`non-constructor`: 메서드(ES6 메서드 축약 표현만), 화살표 함수가 여기에 해당

🙏 ECMAScript 사양에서 메서드로 인정하는 범위는 좁다는 것에 주의!!

### 👉 new 연산자

constructable 함수 앞에 new 연산자를 사용해 생성자 함수로 호출할 수 있다. 이때 new 연산자로 호출된 함수 내부에서 this는 생성자 함수가 생성할 인스턴스, 일반적인 함수 호출에서 this는 전역 객체 window를 가리킨다.

### 👉 new.target

new 연산자 없이 호출되는 것을 방지하기 위해 ES6에서 `new.target`을 지원

new 연산자로 호출한 함수 내부에서 `this` 대신 `new.target`을 사용하면 `new.target`은 `this`와 같은 역할을 하지만, 아니라면 `undefined`를 반환한다.

### 스코프 세이프 생성자 패턴

`new.target`이 도입되지 않은 IE에서 활용할 수 있는 방법

```jsx
// Scope-Safe Constructor Pattern
function Circle(radius) {
   // 생성자 함수가 new 연산자와 함께 호출되면 함수의 선두에서 빈 객체를 생성하고 this에 바인딩한다.
   // 이때 this와 Circle은 프로토타입에 의해 연결된다.

   // 이 함수가 new 연산자와 함께 호출되지 않았다면 이 시점의 this는 전역 객체 window를 가리킨다.
   // 즉, this와 Circle은 프로토타입에 의해 연결되지 않는다.
   if (!(this instanceof Circle)) {
     // new 연산자와 함께 재귀 호출하여 인스턴스를 반환한다.
     return new Circle(radius);
   }

   this.radius = radius;
   this.getDiameter = function () {
     return 2 * this.radius;
   }
 }

// new 연산자 없이 생성자 함수를 호출하여도 생성자 함수로서 호출된다.
const c1 = Circle(5);
console.log(c1.getDiameter()); // 10
```

🙋‍♀️ 참고 사항(질문 형태)