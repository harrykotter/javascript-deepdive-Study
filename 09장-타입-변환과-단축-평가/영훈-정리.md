# 9장 연산자

## 타입 변환

<aside>
💡 일정 상황에서 값이 본연의 데이터 타입이 아닌 다른 데이터 타입으로 바뀌는 것
원시값 자체가 바뀌지 않고 기존 원시값을 이용한 새로운 타입의 원시값을 가지는 것

</aside>

> **명시적 타입 변환** or **타입 캐스팅 ecplicit coercion**
개발자가 함수를 통해 의도적으로 타입을 변환
ex. .toSrting(), Number()

**암묵적 타입 변환 or 타입 강제 변환  implicit coercion**
의도와 상관 없이 JS엔진에 의해 암묵적으로 일어난 변환
ex. 5 + ‘’ ⇒ ‘5’+’’ ⇒ ‘5’
> 

## 암묵적 타입 변환

### 👉 문자열 타입으로 변환

```jsx
//피연산자가 모두 문자열 타입이여야 하는 문맥
5 + '' // -> '5'
'string' + true // -> 'stringtrue'
```

ES6에 도입된 템플릿 리터럴의 표현식 삽입을 통해 문자열 안에 평가 결과를 삽입할 수 있다.

```jsx
`1 + 1 = ${1+1}` // -> '1 + 1 = 2'
```

### 👉 숫자 타입으로 변환

`+`를 제외한 모든 산술 연산자는 피연산자가 모두 숫자여야하므로 타입 변환이 일어난다.

🙅‍♀️ 빈 문자열, 빈 배열, null, false는 0으로, true는 1로 변환된다. 객체와 빈 배열이 아닌 배열, undefined는 변환되지 않고 NaN이 된다는 것에 주의

### 👉 불리언 타입으로 변환

<aside>
💡 `숫자 타입으로의 변환`에서 쓰인듯 숫자 0은 false, 1은 true로 변환되지만,  정확히는 **truthy 값**(참으로 평가되는)과 **falsy 값**(거짓으로 평가되는 값으로 구분한다)

</aside>

## 명시적 타입 변환

🙏 명시적 타입 변환은 개발자가 의도적으로 변환이 일어나게끔 하는것, 여기에는 암묵적 타입 변환을 응용하는 법도 포함된다. built-in 함수를 찾아보거나 암묵적 타입 변환을 활용하는 법을 찾아보자

## **단축 평가**

### 👉 논리연산자를 사용한 단축 평가

<aside>
💡 논리 연산의 결과를 결정하는 피연산자가 타입 변환되지 않고 그대로 반환되는 평가

</aside>

> 논리 연산자 중 논리합 `||`과 논리곱 `&&`은 피연산자에 따라 평가 값이 불린값이 아닐 수도 있다. 다시 말해, 논리합 `||`과 논리곱 `&&`은 피연산자 중 어느 한쪽으로 평가된다.
> 

 논리곱 `&&`의 경우: 앞의 피연산자는 truthy, falsy값으로 평가된 후, falsy라면 바로 false가 출력되지만 truthy라면 뒤의 피연산자를 따라가게된다. 이때 나오는 평가 값은 불린이 아닌 뒷 피연산자가 나오게 된다.

```jsx
'cat'&&'dod' // -> 'dog'
```

논리합 `||`의 경우: 앞의 피연산자가 truthy라면 바로 앞 피연산자가 출력되지만, falsy라면 뒤의 피연산자를 따라가게된다. 이때 나오는 평가 값 역시 불린이 아닌 뒷 피연산자가 나오게 된다.

```jsx
'cat' || 'dog' // -> 'cat'
false || 'dog' // -> 'dog'
'cat' || false // -> 'cat'
```

### 👉 옵셔널 체이닝 연산자 `?.`

<aside>
💡 좌항의 피연산자가 null 또는 undefined인 경우 undefined를 반환하고, 그렇지 않으면 우항의 property 참조를 이어간다.

</aside>

```jsx
let elem = null;

// elem이 null 또는 undefined이면 undefined를 반환하고, 그렇지 않으면 우항의 property 참조를 이어간다.
let value = elem?.value;

consle.log(value); // undefined
```

### 👉 null 병합 연산자 `??`

<aside>
💡 좌항의 피연산자가 null 또는 undefined인 경우 우항의 피연산자를 반환, 그렇지 않으면 좌항의 피연산자를 반환

</aside>

```jsx
// 좌항의 피연산자가 null 또는 undefined이면 우항의 피연산자를 반환하고,
// 그렇지 않으면 좌항의 피연산자를 반환한다.
let foo = null ?? 'default string';
console.log(foo); // 'default string'
```